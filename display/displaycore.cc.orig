

#include <iostream> //temp
#include "display/displaycore.h"
#include "display/displaygeometry.h"
#include "display/displaypfobjects.h"
#include <cmath>

Display::Display(std::list<std::string> views)
{
   if (views.size()==0) {
      views = {"xy", "yz", "xz"};
   }
   
   for(auto view : views)
   {
      //std::cout<< view << " " << view.find("thetaphi") << " and  " << view.npos <<std::endl;
      if (view =="xy"| view == "yz"|view == "xz" ){
         m_views[view] = std::unique_ptr<ViewPane>{new ViewPane(view, view,
                                                                100, -4, 4, 100, -4, 4)};
      }
      else if (view.find("thetaphi")!=view.npos) {
         m_views[view] = std::unique_ptr<ViewPane>{new ViewPane(view, view,
                                      100, -M_PI/2., M_PI/2.,
                                      100, -M_PI, M_PI,
                                      500, 1000)};
      }
   }
   
};
void Display::Register(std::shared_ptr<Drawable>  obj, int layer, bool clearable) {
   for (auto const & view : m_views){
      view.second->Register(obj,layer, clearable);
   }
   
   /*elems = [obj];
    if hasattr(obj, '__iter__'):
    elems = obj
    for elem in elems:
    for view in m_views.values():
    view.register(elem, layer, clearable)*/
};


void Display::Clear(){
   for (auto const & view  : m_views){
      view.second->Clear();
   }
}

void Display::Unzoom() {
   for (auto const & view : m_views){
      view.second->Unzoom();
   }
}
void Display::Draw() const {
   for (auto const & view : m_views){
      view.second->Draw();
   }
}



ViewPane::ViewPane(std::string name, std::string projection, int nx, double xmin, double xmax, int ny, double ymin, double ymax,  int dx , int dy) :
m_canvas(name.c_str(), name.c_str(), 50. + ViewPane::nviews * (dx+10.), 50., dx, dy),m_projection(projection)
{
   
   //double tx = 50. + ViewPane::nviews * (dx+10.) ;
   //double  ty = 50.;
   //m_canvas = TCanvas(name.c_str(), name.c_str(), tx, ty, dx, dy);
   TH1::AddDirectory(false);
   m_hist = TH2F(name.c_str(), name.c_str(), nx, xmin, xmax, ny, ymin, ymax);
   TH1::AddDirectory(true);
   m_hist.Draw();
   m_hist.SetStats(false);
   
   ViewPane::nviews += 1 ;
}


void ViewPane::Register(std::shared_ptr<Drawable> obj, int layer,bool clearable){
   m_registered.push_back(std::pair<std::shared_ptr<Drawable> ,int> { obj,layer});
   //std::cout<<"vector "<< m_registered.size();
   if (!clearable) { // these things we always want
     m_locked.push_back(std::pair<std::shared_ptr<Drawable> ,int> {obj,layer});
   }
}

void ViewPane::Clear(){// clear everything except locked items
   m_registered = m_locked;
}

void ViewPane::Draw(){
   m_canvas.cd();
   
   //sort m_registered by layer
   std::sort(m_registered.begin(), m_registered.end(),
             [](const std::pair<std::shared_ptr<Drawable>,int> &left, const std::pair<std::shared_ptr<Drawable>,int> &right) {
                return left.second < right.second;
             });
   std::cout<<"vector "<< m_registered.size();

   for (auto const & reg :m_registered)
   {
      reg.first->Draw(m_projection);
   }
   
   m_canvas.Update();
   ;
  
}

void ViewPane::Zoom(double xmin, double xmax, double ymin,double  ymax)
{
   m_hist.GetXaxis()->SetRangeUser(xmin, xmax);
   m_hist.GetYaxis()->SetRangeUser(ymin, ymax);
   m_canvas.Update();
}

void ViewPane::Unzoom(){
   m_hist.GetXaxis()->UnZoom();
   m_hist.GetYaxis()->UnZoom();
   m_canvas.Modified();
   m_canvas.Update();
}