#include <iostream>
#include "display/displaypfobjects.h"




GBlob::GBlob(const Cluster& cluster)
{
   //self.cluster = cluster
   TVector3 pos = cluster.getPosition();
   double radius = cluster.getSize();
   double thetaphiradius = cluster.getAngularSize();
   
   
   
   m_layer=cluster.getLayer();
   
   int color = 1;
   if (cluster.getPdgid() == 22 or cluster.getPdgid() == 11)
      color = 2;
   else if (cluster.getPdgid()>0)
      color = 4;
   
   
   //TEllipse m_contourXy(pos.X(), pos.Y(), radius);
   //TEllipse m_contourYz = TEllipse(pos.Z(), pos.Y(), radius);
   //TEllipse m_contourXz = TEllipse(pos.Z(), pos.X(), radius);
   //TEllipse m_contourThetaphi = TEllipse(math.pi/2. - pos.Theta(), pos.Phi(),
   //                                thetaphiradius);
   
   m_contours["xy"] = std::unique_ptr<TEllipse> {new TEllipse (pos.X(), pos.Y(), radius)};
   
   double max_energy = Cluster::s_maxenergy;
   double iradius = radius * cluster.getEnergy() / max_energy;
   double ithetaphiradius = thetaphiradius * cluster.getEnergy()/ max_energy;
   
   
   m_inners["xy"] = std::unique_ptr<TEllipse> {new TEllipse (pos.X(), pos.Y(), iradius)};
   
   //self.inner_xy = TEllipse(pos.X(), pos.Y(), iradius)
   //self.inner_yz = TEllipse(pos.Z(), pos.Y(), iradius)
   //self.inner_xz = TEllipse(pos.Z(), pos.X(), iradius)
   //self.inner_thetaphi = TEllipse(math.pi/2. - pos.Theta(), pos.Phi(),
   //                              ithetaphiradius)
   //inners = [self.inner_xy, self.inner_yz, self.inner_xz,
   //          self.inner_thetaphi]
   for (auto const& contour : m_contours)
   {
      contour.second->SetLineColor(color);
      contour.second->SetFillStyle(0);
   }
   for (auto const& inner : m_inners)
   {
      inner.second->SetFillColor(color);
      inner.second->SetFillStyle(3002);
   }
}

void GBlob::Draw( const std::string  & projection, const std::string & opt) const
{
   
   //som things are not sensible so skip these
   if (m_layer=="HCAL_in" && projection == "HCAL_thetaphi" |
       m_layer=="ECAL_in" && projection == "ECAL_thetaphi"  )
      return;
   
   std::string useopt= opt + "psame";
   
   
   if (m_contours.find(projection)!=m_contours.end() ) {
      m_contours.at(projection)->Draw(useopt.c_str());
   }
   //TODOAJR else
   //    raise ValueError('implement drawing for projection ' + projection )
   if (m_inners.find(projection)!=m_inners.end() ) {
      m_inners.at(projection)->Draw(useopt.c_str());
   }
}
/*if projection == 'xy':
 self.contour_xy.Draw(opt+"psame")
 self.inner_xy.Draw(opt+"psame")
 elif projection == 'yz':
 self.contour_yz.Draw(opt+"psame")
 self.inner_yz.Draw(opt+"psame")
 elif projection == 'xz':
 self.contour_xz.Draw(opt+"psame")
 self.inner_xz.Draw(opt+"psame")
 elif projection == 'ECAL_thetaphi':
 if self.cluster.layer == 'ecal_in':
 self.contour_thetaphi.Draw(opt+"psame")
 self.inner_thetaphi.Draw(opt+"psame")
 elif projection == 'HCAL_thetaphi':
 if self.cluster.layer == 'hcal_in':
 self.contour_thetaphi.Draw(opt+"psame")
 self.inner_thetaphi.Draw(opt+"psame")
 else:
 raise ValueError('implement drawing for projection ' + projection )
 */




GTrajectory::GTrajectory(const  std::vector<TVector3>& points, int linestyle, int linecolor) //AJRTODo generalise argumtnet to be a list of things with points
:  m_DrawSmearedClusters (true)
{
   
   int npoints = points.size();
   std::vector<double> X;
   std::vector<double> Y;
   std::vector<double> Z;
   
   for (int i =0 ; i< npoints; i++)
   {
      X.push_back(points[i].X());
      Y.push_back(points[i].Y());
      Z.push_back(points[i].Z());
      //std::cout << "X " << X[i] << "Y " << Y[i]<< "Z " << Z[i];
      
   }
   
   m_graphs["xy"]=std::unique_ptr<TGraph> {new TGraph(npoints,&X[0],&Y[0])};
   m_graphs["yz"]=std::unique_ptr<TGraph> {new TGraph(npoints,&Z[0],&Y[0])};
   m_graphs["xz"]=std::unique_ptr<TGraph> {new TGraph(npoints,&Z[0],&X[0])};
   
   for (auto const  & graph : m_graphs) {
      graph.second->SetMarkerStyle(2);
      graph.second->SetMarkerSize(0.7);
      graph.second->SetLineStyle(linestyle);
      graph.second->SetLineColor(linecolor);
   }
   
   
   
}





void GTrajectory::setColor( int color){
   for (auto const& graph : m_graphs)
   {
      graph.second->SetMarkerColor(color);
   }
   
}

void GTrajectory::Draw( const std::string &  projection ,const std::string  &opt) const{
   /*for (auto blob : m_blobs) {
    blob.Draw(projection, opt);
    }*/
   std::cout << "proj " << projection ;
   std::string usedopt = "lpsame"; //AJRTODO
   
   m_graphs.at(projection) ->Draw(usedopt.c_str()); // [] fails because of const ness
   
   // raise ValueError('implement drawing for projection ' + projection )
   
};



GTrajectories::GTrajectories(const  std::vector<TVector3>& points) //AJRTODO const std::list<Particle>& particles)
{
   
   //TrajClass = GTrajectory ; //AJRTODO GStraightTrajectoryif is_neutral else GHelixTrajectory
   
   
   m_gTrajectories.push_back(GTrajectory(points));
   // display.register(gtraj,1)
}


GTrajectories::GTrajectories(const  Cluster& cluster)
{
   m_gBlobs.push_back(GBlob(cluster));
   
}


void GTrajectories::Draw(const std::string & projection) const{
   for (auto const & traj : m_gTrajectories) {
      traj.Draw(projection);
   }
   for (auto const & traj : m_gBlobs) {
      traj.Draw(projection);
   }
}

